h1. Resourcy

Resourcy is a small (~3k) RESTful resource Ajax "hijacker" that observes Ajax requests matching specific paths and methods (get, put, post, delete).  It's designed to work with Rails 3 by providing hooks for all the standard controller actions (index, show, new, create, edit, update, and destroy), as well the ability to add and remove members (get, put, post, and delete actions) on a given resource.

It's important to note that there's no requirements to get the routes from Rails, it expects you to define only what you want, where you want it.

All you have to do is use @link_to :remote => true@ and @form_for :remote => true@.. and by doing so Resourcy gives you a nice interface for hooking into those Ajax requests.

h2. The Story

I absolutely can't stand RJS and refuse to use it.  I prefer to keep all my Javascript in one place -- outside of my application, and structured in a sensible way for _Javascript_.  Javascript doesn't always retain a one to one relationship with server code, and because of that it seems important to have simple and elegant ways to get them to interact nicely.

After working in Rails 3 for a little while I realized that there wasn't a great way to handle custom remote links and forms.. There's ways, but it's not especially elegant.  So, let's take a quick look at how you can accomplish this in Rails 3:

Let's say we have a link that when clicked, updates some content elsewhere on the page based on a JSON response from the server.  In the view I can use the handy @link_to@ helper like so:

<pre>
link_to 'Activate Post', activate_post_path(@post), :remote => true
</pre>

This is absolutely great.. simple, concise and communicates very useful information to other developers (and myself 6 months down the road) that we're doing something specific with this link.  Now, with my aversion to RJS, I don't want to create an RJS response, cause really, I'd rather work with JSON.  So, there's two feasible options for that.

1. We drop the @remote => true@ part and put an id on the link so we can find it, observe clicks on it, and do the Ajax custom style.. which is ok, but doesn't communicate as clearly that there's stuff being handled on the client and that the controller should be responding to our link in a particular way.

2. We (again) add an id to the link so we can find it, leaving the @remote => true@ intact.  The Javascript that comes with Rails 3 allows us to handle some of the Ajax events by firing custom events during the Ajax process, so (again) we find the element, but instead of observing click, we attach some observers for "ajax:before" (maybe we want to animate in a loading indicator?), "ajax:success", "ajax:failure", and potentially more.  That gets the job done, but we have several bits of code that aren't really communicative of what's going on in Javascript now, and we can't control if the Ajax request goes through or not.

Neither one of those options sounded great to me.  Which left me thinking about how it could be accomplished better.  After talking with a few people and looking at some existing options we came up with an idea.  What if we watched Ajax requests themselves, and were able to listen to specific methods and potentially handle the default REST actions?  Right, who couldn't like that idea?  It's very Rails-ish, and allows us room to play.. say using it outside of Rails for a Rack application.

Here's a simple example of how it can be used:

<pre>
  Rails.resource('posts').add('show', function() {
    return {
      onSuccess: function() { alert('Yay!') }
      onFailure: function() { alert('Boo!') }
    }
  });
</pre>

Simple and concise.. Now whenever a remote link is clicked with the path of /posts/:post_id and method of GET (PostsController#show) we get to handle it.  We can also put this code where it seems appropriate in the context that we might need it.  The best part is that this is just the simplest example.

h2. Installation

It's expected that you have the default Rails setup (eg. prototype.js, and rails.js) for now.  Support for jQuery and others will be added as the needs arise.. Requests and feedback always help inspire me to get something written even though I might not need it myself.

* Grab "resourcy.js":http://github.com/jejacks0n/resourcy/raw/master/public/distro/resourcy.js or "resourcy.min.js":http://github.com/jejacks0n/resourcy/raw/master/public/distro/resourcy.min.js from the @public/distro@ path.
* Put it in your project (/public/javascripts) and include it in your layout using @javascript_include_tag :defaults, 'resourcy.min'@

h2. Usage examples

Note: In our examples we'll be using Prototype, but the same is applicable with any type of object.

Let's say you have a Posts class.  This "class" handles the user interface around browsing blog posts -- updating various elements on the page when you paginate through them etc.

<pre>
  var Posts = Class.create({
    initialize: function() {
      this.display = $('post_display');
    
      Rails.resource('posts').add('index', this.loadPage.bind(this));
    },
  
    loadPage: function() {
      this.display.addClassname('loading');
      return {
      
        onSuccess: function(response) {
          this.display.removeClassname('loading');
          this.display.update(response.responseText);
        }.bind(this),
      
        onFailure: function() {
          this.display.removeClassname('loading');
          alert('Unable to load that page');
        }.bind(this)

      }
    }
  })
</pre>

Notice how we didn't observe any clicking on links or buttons?  We don't care about buttons anymore, because we don't have to.  Whenever an Ajax request to PostsController#index happens we can handle it how we want.  Since we're wanting to handle the index action on the PostsController we indicate that when we add it to the Rails.resource call.

This means that we can put those pagination links wherever we want (let's assume they're in the post_display element for now), potentially add more, or change how they work.. without ever having to touch the client code!

Now let's consider adding a show view for blog posts.  Currently when I click to view a specific blog post it takes me to the show view -- and when I click the back button I lose the page I was on.. So lame!  Let's just show the blog post on the page we're on, so we don't have to refresh the page.  We update our controller to respond to JSON, and do a little refactor in our constructor (so you can see a slightly different usage pattern) like so:

<pre>
  initialize: function() {
    this.display = $('post_display');
  
    Rails.resource('posts').
      add('index', this.loadPage.bind(this)).
      add('show', this.loadDetail.bind(this));
  },
</pre>

Notice we've added one line of javascript to handle the new action, no matter how many links may exist.. We don't have to find and observe any of them because it's happening for us.  Now it's simply a matter of adding @remote => true@ to the links in the index view, writing a loadDetail method, and testing it.

h2. Nested Resources & Namespacing

Resourcy handles namespaces and nested resources.  It's just part of the resource you pass it, so for example, if you have the nested resource "comments" under "posts", you would just use the path to that resource.. eg. 'posts/:post_id/comments'.  This will automatically make a nested resource, which means that if you don't care to do anything for posts, you don't have to declare it as a resource itself.

h3. Nested resources

<pre>
  var r = Rails.resource('blogs/:blog_id/posts');
</pre>

h3. Namespacing

<pre>
  var r = Rails.resource('my_blog/admin/posts');
</pre>

h2. Singular Resources

Singular resources basically work the same way everything else does.  Resourcy doesn't really care if it's a singular resource or, which means that if you have a singular resource, the "show" action is really the "index" action.. Since there's no way to tell Resourcy about this, you should use index instead of show singular resources.

If enough people mention it I'll make an alternate way to create singular resources so it has a concept of that.

h2. Adding actions

  You can add actions and members to a given resource by using the @add@ method, which supports chaining.

<pre>
  var r = Rails.resource('posts').
    add('index',       function() {}).
    add('show',        function() {});
    
  r.add('new',         function() {}).
    add('create',      function() {}).
    add('edit',        function() {}).
    add('update',      function() {}).
    add('destroy',     function() {}).
    add('put:publish', function() {}).
    add('put:archive', function() {}).
    add('delete:comments', function() {});
</pre>

h2. Removing actions

There are times when you may want to remove an existing action on a resource.  You can accomplish this by using the @remove@ method.

<pre>
  var r = Rails.resource('posts').add('index', function() {});

  r.remove('index');
  // - or -
  Rails.resource('posts').remove('index');
</pre>

h2. Returning from your callback

Your callback functions can return a few things to control what happens to the Ajax request after you've done what you want.  Your function is called directly before the Ajax request is made, so you have control over if the Ajax request goes through or not, as well as what options it should use.

h3. Returning false

To keep the Ajax request from continuing simply return false.  This will stop the request, which let's you do custom confirm dialogs etc.  We'll use the example above as a starting point for some of these examples as well.

<pre>
  loadDetails: function() {
    // you can stop the ajax request by returning false
    return confirm('Are you sure?');
  }
</pre>

h3. Returning Ajax options

You can also control the options the Ajax request will use by returning them.  This allows you to setup things like onSuccess and other callbacks.

<pre>
  loadDetails: function() {
    // you can return an options object that will be used by the Ajax request
    return {
      onSuccess: function() { alert('You loaded the details!') }
      onFailure: function() { alert("That post wasn't found") }
    }
  }
</pre>

h2. Arguments for callback functions

The callback functions you assign are passed a few arguments when they're called.  These are important because they give you a lot of flexibility.  The arguments passed are:

* @proceed@ a callback function that can be called to continue the Ajax request (useful for animating or something before actually sending the request)
* @pathVars@ variables that are from the path -- if the resource was 'blogs/:blog_id/posts' for example, this would be something like: {blog_id: '42'}

<pre>
  loadDetails: function(proceed, pathVars) {
    // you can use the proceed function to pass as a callback or call it yourself
    // if you pass it as a callback and it isn't called immediately you should return false so it isn't called for you
    
    // this will wait 10 seconds before making the actual ajax request
    setTimeout(proceed({
      onSuccess: function() { alert('You loaded the details for ' + pathVars['blog_id'] + '!') },
      onFailure: function() { alert("That post wasn't found") }
    }), 10000);
    return false;
  }
</pre>

h2. Describing routes

Since Resourcy is basically a routing system it can be useful to see all of the routes you're listening for.  The @routes@ method returns an array of all of the resources and actions as route descriptions.

<pre>
  console.debug(Rails.routes());
</pre>

h2. Enjoy. =)